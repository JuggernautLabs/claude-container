#!/usr/bin/env bash
# Spawn into a Docker container with Claude Code ready to execute
#
# Usage:
#   claude-container [dockerfile] [--build] [--dir <path>]
#   claude-container                    # Use ./Dockerfile or ./.devcontainer/Dockerfile
#   claude-container path/to/Dockerfile # Use specific Dockerfile
#   claude-container --build            # Force rebuild image
#   claude-container --dir ./myproject  # Use overlay for myproject directory
#
# Environment:
#   CLAUDE_CODE_OAUTH_TOKEN  OAuth token for authentication (required)

set -e

VERSION="0.1.0"
DEFAULT_IMAGE="ghcr.io/hypermemetic/claude-container:latest"

# Config and cache directories
CONFIG_DIR="$HOME/.config/claude-container"
CACHE_DIR="$CONFIG_DIR/cache"

# Ensure directories exist
mkdir -p "$CONFIG_DIR" "$CACHE_DIR"
chmod 700 "$CONFIG_DIR"

# Source library modules (resolve symlinks to find actual script location)
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "$0" 2>/dev/null || realpath "$0" 2>/dev/null || echo "$0")")" && pwd)"
source "$SCRIPT_DIR/lib/utils.sh"
source "$SCRIPT_DIR/lib/platform.sh"
source "$SCRIPT_DIR/lib/config.sh"
source "$SCRIPT_DIR/lib/auth.sh"
source "$SCRIPT_DIR/lib/docker.sh"
source "$SCRIPT_DIR/lib/git-session.sh"
source "$SCRIPT_DIR/lib/git-ops.sh"
source "$SCRIPT_DIR/lib/session-mgmt.sh"

# Global state variables
DOCKERFILE=""
FORCE_BUILD=false
SESSION_DIR=""
VERIFY_MODE=false
SESSION_NAME=""
SESSION_NAME_SET=false
USE_GIT_SESSION=true  # Default: use git-based session isolation
CONTINUE_SESSION=false
RUN_AS_USER=false
RUN_AS_ROOTISH=true  # Default: run as user with passwordless sudo for package installs
AUTO_SYNC_BRANCH=""
NO_RUN=false
SHELL_ONLY=false
BASH_EXEC=""  # Command to execute instead of claude
ENABLE_DOCKER=false  # Mount Docker socket for host Docker access
CONFIG_ONLY=false    # Just generate config, don't create session
SCAN_SESSION=false   # Scan session for new repos
DISCOVER_REPOS_DIRS=()  # Array for multiple --discover-repos
SESSIONS_CONFIG_DIR="$CONFIG_DIR/sessions"  # Where session configs are stored

# Docker args accumulator
declare -a DOCKER_ARGS

# Handle cleanup commands (before main argument parsing)
case "${1:-}" in
    --cleanup)
        session_cleanup
        exit 0
        ;;

    --cleanup-unused)
        shift
        session_cleanup_unused "$@"
        exit 0
        ;;

    --list-sessions|--sessions)
        session_list
        exit 0
        ;;

    --delete-session)
        shift
        session_delete "$@"
        exit 0
        ;;

    --restart-session)
        shift
        session_restart "$@"
        exit 0
        ;;

    --diff-session)
        session_diff "$2" "$(pwd)" "${3:-}"
        exit 0
        ;;

    --merge-session)
        shift
        session_merge "$@"
        exit 0
        ;;

    --add-repo)
        # Usage: --add-repo <session> <repo-path> [workspace-path]
        shift
        session_add_repo "$@"
        exit 0
        ;;
esac

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --build|-b)
            FORCE_BUILD=true
            shift
            ;;
        --dir|-d)
            SESSION_DIR="$2"
            shift 2
            ;;
        --verify|-v)
            VERIFY_MODE=true
            shift
            ;;
        --session|-s)
            SESSION_NAME="$2"
            SESSION_NAME_SET=true
            shift 2
            ;;
        --no-git-session)
            USE_GIT_SESSION=false
            shift
            ;;
        --config-only)
            CONFIG_ONLY=true
            shift
            ;;
        --scan)
            SCAN_SESSION=true
            shift
            ;;
        --continue|-c)
            CONTINUE_SESSION=true
            shift
            ;;
        --as-user)
            RUN_AS_USER=true
            shift
            ;;
        --as-rootish)
            RUN_AS_ROOTISH=true
            shift
            ;;
        --as-root|--no-rootish)
            RUN_AS_ROOTISH=false
            RUN_AS_USER=false
            shift
            ;;
        --auto-sync)
            AUTO_SYNC_BRANCH="$2"
            shift 2
            ;;
        --discover-repos)
            DISCOVER_REPOS_DIRS+=("$2")
            shift 2
            ;;
        --config|-C)
            CONFIG_FILE="$2"
            shift 2
            ;;
        --no-run)
            NO_RUN=true
            shift
            ;;
        --shell|--bash)
            SHELL_ONLY=true
            shift
            ;;
        --bash-exec)
            BASH_EXEC="$2"
            shift 2
            ;;
        --docker)
            ENABLE_DOCKER=true
            shift
            ;;
        --dockerfile|-f)
            # Specify explicit Dockerfile path (auto-detected if not provided)
            if [[ -n "${2:-}" ]] && [[ ! "$2" =~ ^- ]]; then
                DOCKERFILE="$2"
                shift 2
            else
                shift
            fi
            ;;
        --version|-V)
            echo "claude-container $VERSION"
            exit 0
            ;;
        --help|-h)
            cat <<EOF
Usage: claude-container [options]

Spawn into a Docker container with Claude Code ready.

Options:
  --build, -b              Force rebuild the image
  --dockerfile, -f [path]  Specify Dockerfile path (auto-detected from ./Dockerfile if present)
  --dir, -d <path>         Directory to use with overlay (DEPRECATED)
  --session, -s <name>     Session name (required, identifies the session)
  --no-git-session         Disable git-based isolation (mount cwd directly)
  --config-only            Generate config file only, don't create session (outputs path)
  --scan                   Scan session for new repos, prompt for destinations, update config
  --continue, -c           Continue the most recent Claude conversation
  --as-user                Run as non-root developer user (no sudo)
  --as-rootish             Run as developer with passwordless sudo for installs (default)
  --as-root, --no-rootish  Run as actual root user
  --auto-sync <branch>     Override branch name for auto-merge on exit (default: session name)
  --discover-repos <dir>   Auto-discover all git repos in directory
  --config, -C <path>      Explicit path to .claude-projects.yml config file
  --verify, -v             Verify container setup works (run checks and exit)
  --shell, --bash          Start bash shell instead of claude
  --bash-exec <cmd>        Execute a bash command and exit
  --docker                 Mount Docker socket for host Docker access (security risk on Linux)
  --version, -V            Show version
  --help, -h               Show this help

Session Management:
  --cleanup                List and optionally delete all claude-related volumes
  --cleanup-unused [--yes] Delete volumes not used by running containers
  --list-sessions, --sessions  List all sessions with disk usage per volume
  --delete-session <name> [--regex] [--yes]  Delete session(s) with confirmation
  --restart-session <name> Restart a session (fixes permissions, continues conversation)
  --diff-session <name>    Show changes made in a git session vs original repo
  --merge-session <name>   Merge session commits back to repo
                           Options: --into <branch> (target branch, default: session name)
                                    --from <branch> (create new branch from this, default: HEAD)
  --add-repo <session> <path> [name]  Add a repo to an existing session

Environment:
  CLAUDE_CODE_OAUTH_TOKEN   OAuth token for authentication (required)
                            Get one with: claude setup-token

Examples:
  claude-container -s myproj                           # Start git session "myproj"
  claude-container -s myproj --discover-repos ~/dev    # Discover repos and start session
  claude-container -s myproj --continue                # Resume session AND continue conversation
  claude-container -s myproj --scan                    # Find new repos created in session
  claude-container --no-git-session                    # Direct mount cwd (no isolation)
EOF
            exit 0
            ;;
        *)
            error "Unknown option: $1"
            echo "Run 'claude-container --help' for usage"
            exit 1
            ;;
    esac
done

# Validate session name is provided when required
if ($USE_GIT_SESSION || $CONFIG_ONLY || $SCAN_SESSION) && [[ -z "$SESSION_NAME" ]]; then
    error "Session name required: use --session <name>"
    exit 1
fi

# Ensure session config directory exists
mkdir -p "$SESSIONS_CONFIG_DIR"

# Handle --scan: scan session for new repos and exit
if $SCAN_SESSION; then
    session_scan "$SESSION_NAME"
    exit 0
fi

# Ensure token is available (from config, keychain, or interactive auth)
ensure_token

# Check for YAML parser if we'll need it (multi-project mode)
if $USE_GIT_SESSION || [[ -n "$CONFIG_FILE" ]]; then
    will_use_config=false
    if [[ -n "$CONFIG_FILE" ]]; then
        will_use_config=true
    elif $USE_GIT_SESSION; then
        workspace="${WORKSPACE_DIR:-$(pwd)}"
        for candidate in \
            "$workspace/.claude-projects.yml" \
            "$workspace/.devcontainer/claude-projects.yml" \
            "$workspace/claude-projects.yml"; do
            if [[ -f "$candidate" ]]; then
                will_use_config=true
                break
            fi
        done
    fi

    if $will_use_config && ! check_yaml_parser_available; then
        echo ""
        warn "Multi-project config detected but YAML parser not available"
        show_yaml_parser_install_help
        exit 1
    fi
fi

# Determine image to use
# Auto-detect local Dockerfile unless explicit path given via --dockerfile
if [[ -z "$DOCKERFILE" ]]; then
    # Search for Dockerfile in standard locations
    for candidate in "./Dockerfile" "./.devcontainer/Dockerfile" "./docker/Dockerfile"; do
        if [[ -f "$candidate" ]]; then
            DOCKERFILE="$candidate"
            break
        fi
    done
fi

if [[ -n "$DOCKERFILE" ]]; then
    if [[ ! -f "$DOCKERFILE" ]]; then
        error "Dockerfile not found: $DOCKERFILE"
        exit 1
    fi
    USE_DEFAULT_IMAGE=false
else
    # No local Dockerfile found, use default image
    USE_DEFAULT_IMAGE=true
    IMAGE_NAME="$DEFAULT_IMAGE"
fi

if $USE_DEFAULT_IMAGE; then
    IMAGE_EXISTS=$(docker images -q "$IMAGE_NAME" 2>/dev/null)
    if [[ -z "$IMAGE_EXISTS" ]] || $FORCE_BUILD; then
        info "Pulling image: $IMAGE_NAME"
        docker pull "$IMAGE_NAME" &
        spin $!
        wait $!
        success "Image pulled: $IMAGE_NAME"
        echo ""
    fi
else
    info "Using Dockerfile: $DOCKERFILE"
    CONTEXT_DIR="$(dirname "$DOCKERFILE")"
    if [[ "$CONTEXT_DIR" == "." ]]; then
        CONTEXT_DIR="$(pwd)"
    fi
    PROJECT_NAME="$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]-')"
    IMAGE_NAME="claude-dev-${PROJECT_NAME}"

    IMAGE_EXISTS=$(docker images -q "$IMAGE_NAME" 2>/dev/null)
    if [[ -z "$IMAGE_EXISTS" ]] || $FORCE_BUILD; then
        info "Building image: $IMAGE_NAME"
        docker build -t "$IMAGE_NAME" -f "$DOCKERFILE" "$CONTEXT_DIR" &
        spin $!
        wait $!
        success "Image built: $IMAGE_NAME"
        echo ""
    fi
fi

# Prepare mount points
WORKSPACE_DIR="$(pwd)"
USE_OVERLAY=false

# Handle session directory with overlay (deprecated)
SESSION_VOLUME=""
if [[ -n "$SESSION_DIR" ]]; then
    warn "The --dir option is deprecated. Consider using --git-session instead."
    SESSION_DIR="$(cd "$SESSION_DIR" && pwd)"
    SESSION_UUID="$(uuidgen | tr '[:upper:]' '[:lower:]')"
    SESSION_VOLUME="session-data-${SESSION_UUID}"
    info "Creating session volume: $SESSION_VOLUME"
    docker volume create "$SESSION_VOLUME" >/dev/null
    USE_OVERLAY=true
    WORKSPACE_DIR="$SESSION_DIR"
fi

# Handle --config-only: generate config and exit
if $CONFIG_ONLY; then
    if [[ ${#DISCOVER_REPOS_DIRS[@]} -gt 0 ]]; then
        # Discover repos and write config to session config dir
        discovered_config=$(discover_repos_multi "${DISCOVER_REPOS_DIRS[@]}")
        session_config="$SESSIONS_CONFIG_DIR/${SESSION_NAME}.yml"
        cp "$discovered_config" "$session_config"
        rm -f "$discovered_config"
        success "Config written to: $session_config"
        echo "$session_config"
        exit 0
    elif [[ -n "${CONFIG_FILE:-}" ]]; then
        # Copy provided config to session config dir
        session_config="$SESSIONS_CONFIG_DIR/${SESSION_NAME}.yml"
        cp "$CONFIG_FILE" "$session_config"
        success "Config copied to: $session_config"
        echo "$session_config"
        exit 0
    else
        error "--config-only requires --discover-repos or --config"
        exit 1
    fi
fi

# Handle git-based session isolation (recommended)
GIT_SESSION_VOLUME=""
if $USE_GIT_SESSION; then
    GIT_SESSION_VOLUME="claude-session-${SESSION_NAME}"

    # If --discover-repos was specified, write config to session config dir first
    if [[ ${#DISCOVER_REPOS_DIRS[@]} -gt 0 ]]; then
        discovered_config=$(discover_repos_multi "${DISCOVER_REPOS_DIRS[@]}")
        session_config="$SESSIONS_CONFIG_DIR/${SESSION_NAME}.yml"
        cp "$discovered_config" "$session_config"
        rm -f "$discovered_config"
        CONFIG_FILE="$session_config"
        info "Session config: $session_config"
    fi

    create_git_session "$SESSION_NAME" "$WORKSPACE_DIR"

    if $NO_RUN; then
        success "Session ready: $SESSION_NAME"
        exit 0
    fi
fi

# Build docker run command
DOCKER_ARGS=(
    "--rm"
    "--name" "claude-dev-$$"
    "-w" "/workspace"
)

# Add TTY based on CI detection and terminal availability
if $IS_CI; then
    :
elif ! $VERIFY_MODE && [[ -t 0 ]]; then
    DOCKER_ARGS+=("-it")
fi

# Mount workspace
if $USE_GIT_SESSION; then
    DOCKER_ARGS+=("-v" "$GIT_SESSION_VOLUME:/workspace")
elif $USE_OVERLAY; then
    DOCKER_ARGS+=(
        "--privileged"
        "--device" "/dev/fuse"
        "-v" "$WORKSPACE_DIR:/workspace-lower:ro"
        "-v" "$SESSION_VOLUME:/session-data"
        "-e" "USE_OVERLAY=1"
        "-e" "SESSION_VOLUME=$SESSION_VOLUME"
    )
else
    DOCKER_ARGS+=("-v" "$WORKSPACE_DIR:/workspace")
fi

# Mount git config and SSH
DOCKER_ARGS+=(
    "-v" "$HOME/.gitconfig:/root/.gitconfig:ro"
    "-v" "$HOME/.ssh:/root/.ssh:ro"
)

# Forward SSH agent if available
SSH_SOCKET_ARGS=$(get_ssh_socket_args)
if [[ -n "$SSH_SOCKET_ARGS" ]]; then
    # shellcheck disable=SC2086
    DOCKER_ARGS+=($SSH_SOCKET_ARGS)
fi

# Add environment variables
DOCKER_ARGS+=(
    "-e" "TERM=${TERM:-xterm-256color}"
    "-e" "HOST_UID=$(get_host_uid)"
    "-e" "HOST_GID=$(get_host_gid)"
    "-e" "PLATFORM=$PLATFORM"
    "-e" "IS_CI=$IS_CI"
)

# Inject token securely
inject_token_securely "${CLAUDE_CODE_OAUTH_TOKEN}"

# Set up session state and dev caches
setup_session_state "$SESSION_NAME"
setup_dev_caches "$SESSION_NAME"

if $VERIFY_MODE; then
    DOCKER_ARGS+=("-e" "VERIFY_MODE=1")
fi

if $CONTINUE_SESSION; then
    DOCKER_ARGS+=("-e" "CONTINUE_SESSION=1")
fi

if $RUN_AS_USER; then
    DOCKER_ARGS+=("-e" "RUN_AS_USER=1")
fi

if $RUN_AS_ROOTISH; then
    DOCKER_ARGS+=("-e" "RUN_AS_ROOTISH=1")
fi

if $SHELL_ONLY; then
    DOCKER_ARGS+=("-e" "SHELL_ONLY=1")
fi

if [[ -n "$BASH_EXEC" ]]; then
    DOCKER_ARGS+=("-e" "BASH_EXEC=$BASH_EXEC")
fi

if $ENABLE_DOCKER; then
    # Verify Docker is accessible from host
    DOCKER_AVAILABLE=false
    if command -v docker &>/dev/null; then
        DOCKER_HOST_URL=$(docker context inspect --format '{{.Endpoints.docker.Host}}' 2>/dev/null)
        if [[ -n "$DOCKER_HOST_URL" ]] && [[ "$DOCKER_HOST_URL" == unix://* ]]; then
            HOST_SOCKET="${DOCKER_HOST_URL#unix://}"
            if [[ -S "$HOST_SOCKET" ]]; then
                DOCKER_AVAILABLE=true
            fi
        fi
    fi

    if $DOCKER_AVAILABLE; then
        # Mount the VM-side socket (works for Colima/Docker Desktop on macOS)
        # Containers run inside the VM, so they access /var/run/docker.sock directly
        DOCKER_ARGS+=("-v" "/var/run/docker.sock:/var/run/docker.sock")
        DOCKER_ARGS+=("-e" "DOCKER_HOST=unix:///var/run/docker.sock")
        if [[ "$PLATFORM" == "linux" ]]; then
            warn "Docker socket mounted - this grants full Docker access"
            warn "On Linux, this is equivalent to root access on the host"
        else
            info "Docker socket mounted (VM: /var/run/docker.sock)"
        fi
    else
        warn "Could not find Docker socket - --docker will not work"
        if command -v docker &>/dev/null; then
            warn "Active context: $(docker context show 2>/dev/null || echo 'unknown')"
        fi
    fi
fi

info "Starting container..."
echo "  Image: $IMAGE_NAME"
if $USE_GIT_SESSION; then
    echo "  Workspace: $GIT_SESSION_VOLUME -> /workspace (git session)"
else
    echo "  Workspace: $WORKSPACE_DIR -> /workspace"
fi
echo "  Platform: $PLATFORM"
echo "  State: claude-state-${SESSION_NAME}"
if $IS_CI; then
    echo "  CI Mode: enabled"
fi
if $USE_OVERLAY; then
    echo "  Session: $SESSION_VOLUME (overlay mode - deprecated)"
fi
if $USE_GIT_SESSION; then
    echo "  Git Session: $SESSION_NAME"
fi
if $ENABLE_DOCKER && ${DOCKER_AVAILABLE:-false}; then
    echo "  Docker: enabled (/var/run/docker.sock)"
fi
echo ""

# Run container with entrypoint script
docker run "${DOCKER_ARGS[@]}" "$IMAGE_NAME" /bin/bash -c '
    set -e

    # Read token from securely mounted file
    export CLAUDE_CODE_OAUTH_TOKEN=$(cat /run/secrets/claude_token)

    HOST_UID=${HOST_UID:-1000}
    DEV_GID=61000

    # Set up overlayfs if requested
    if [[ "${USE_OVERLAY:-}" == "1" ]]; then
        echo "Setting up overlay filesystem..."
        mkdir -p /session-data/upper /session-data/work
        rmdir /workspace 2>/dev/null || rm -f /workspace 2>/dev/null || true
        mkdir -p /workspace
        if fuse-overlayfs \
            -o lowerdir=/workspace-lower,upperdir=/session-data/upper,workdir=/session-data/work \
            /workspace 2>&1; then
            echo "  Overlay mounted at /workspace"
        else
            mount --bind /workspace-lower /workspace 2>/dev/null || ln -sf /workspace-lower /workspace
            echo "  Fallback: direct mount, read-only"
        fi
        cd /workspace
        echo ""
    fi

    # Set up home directory
    mkdir -p /home/developer/.claude /home/developer/.cargo /home/developer/.npm /home/developer/.cache/pip

    # Create .claude.json with settings
    cat > /home/developer/.claude.json << EOF
{"theme":"dark-ansi","hasCompletedOnboarding":true,"bypassPermissionsModeAccepted":true}
EOF

    # Copy git config
    if [[ -f /root/.gitconfig ]]; then
        cp /root/.gitconfig /home/developer/.gitconfig 2>/dev/null || true
    fi

    # Check for docker CLI if socket is mounted
    if [[ -S /var/run/docker.sock ]] && ! command -v docker &>/dev/null; then
        echo "WARNING: docker socket mounted but docker CLI not found"
        echo "         Use --dockerfile to build an image with docker"
    fi

    if [[ "${RUN_AS_USER:-}" == "1" ]] || [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then
        groupadd -g $DEV_GID developer 2>/dev/null || true
        useradd -u $HOST_UID -g $DEV_GID -m -s /bin/bash developer 2>/dev/null || true
        chown -R developer:developer /home/developer
        chown developer:developer /workspace 2>/dev/null || true

        # Make docker socket accessible if mounted
        if [[ -S /var/run/docker.sock ]]; then
            chmod 666 /var/run/docker.sock 2>/dev/null || true
        fi

        if [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then
            if ! command -v sudo &>/dev/null; then
                echo "WARNING: sudo not found - rootish mode requires sudo in the image"
                echo "         Use --dockerfile to build an image with sudo, or use --as-root"
            else
                # Configure passwordless sudo for developer user
                echo "developer ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/developer
                chmod 0440 /etc/sudoers.d/developer

                # Create rootish wrapper that uses sudo
                cat > /usr/local/bin/rootish << '\''WRAPPER'\''
#!/bin/bash
exec sudo "$@"
WRAPPER
                chmod +x /usr/local/bin/rootish
            fi
        fi
    fi

    # Verify mode
    if [[ "${VERIFY_MODE:-}" == "1" ]]; then
        echo "=== Verification ==="
        echo "Run as: $(if [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then echo "developer (sudo)"; elif [[ "${RUN_AS_USER:-}" == "1" ]]; then echo "developer"; else echo "root"; fi)"
        echo "Claude: $(which claude 2>&1)"
        echo "Platform: ${PLATFORM:-unknown}"

        echo ""
        echo "=== Token Check ==="
        if [[ -f /run/secrets/claude_token ]]; then
            echo "  Token file: OK"
            echo "  Token: ${CLAUDE_CODE_OAUTH_TOKEN:0:20}..."
        else
            echo "  Token file missing"
            exit 1
        fi

        echo ""
        echo "=== Claude Test ==="
        HOME=/home/developer claude --print "test" 2>&1 | head -5
        exit 0
    fi

    # Determine working directory (main project if specified, otherwise /workspace)
    WORK_DIR="/workspace"
    if [[ -f /workspace/.main-project ]]; then
        MAIN_PROJ=$(cat /workspace/.main-project)
        if [[ -d "/workspace/$MAIN_PROJ" ]]; then
            WORK_DIR="/workspace/$MAIN_PROJ"
        fi
    fi

    # Shell-only mode - just run bash in working directory
    if [[ "${SHELL_ONLY:-}" == "1" ]]; then
        if [[ "${RUN_AS_USER:-}" == "1" ]] || [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then
            exec gosu developer bash -c "cd $WORK_DIR && exec bash"
        else
            exec bash -c "cd $WORK_DIR && exec bash"
        fi
    fi

    # Bash exec mode - run command and exit
    if [[ -n "${BASH_EXEC:-}" ]]; then
        cd $WORK_DIR
        if [[ "${RUN_AS_USER:-}" == "1" ]] || [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then
            exec gosu developer bash -c "$BASH_EXEC"
        else
            exec bash -c "$BASH_EXEC"
        fi
    fi

    # Run claude
    if [[ "${RUN_AS_USER:-}" == "1" ]] || [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then
        CLAUDE_ARGS="--dangerously-skip-permissions"
    else
        CLAUDE_ARGS=""
    fi

    if [[ "${CONTINUE_SESSION:-}" == "1" ]]; then
        CLAUDE_ARGS="--continue $CLAUDE_ARGS"
    fi

    cd $WORK_DIR
    if [[ "${RUN_AS_USER:-}" == "1" ]] || [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then
        exec gosu developer claude $CLAUDE_ARGS
    else
        HOME=/home/developer exec claude $CLAUDE_ARGS
    fi
'

# Auto-merge on exit: merge any new commits to branch named after session (or specified branch)
if $USE_GIT_SESSION; then
    merge_branch="${AUTO_SYNC_BRANCH:-$SESSION_NAME}"
    echo ""
    info "Merging session commits to branch: $merge_branch"
    "$0" --merge-session "$SESSION_NAME" --into "$merge_branch" --yes || {
        warn "Merge had issues - session preserved for manual merge"
        echo "  To retry: claude-container --merge-session $SESSION_NAME --into $merge_branch"
    }
fi
