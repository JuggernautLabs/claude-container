#!/usr/bin/env bash
# Spawn into a Docker container with Claude Code ready to execute
#
# Usage:
#   claude-container -s <session> [options]
#   claude-container -s myproj                    # Single project from cwd
#   claude-container -s myproj -a ~/repo1 -a ~/repo2  # Multiple projects
#   claude-container -s myproj --discover-repos ~/dev  # Auto-discover repos
#
# Environment:
#   CLAUDE_CODE_OAUTH_TOKEN  OAuth token for authentication (required)

set -e

VERSION="0.2.0"
DEFAULT_IMAGE="ghcr.io/hypermemetic/claude-container:latest"

# Config and cache directories
CONFIG_DIR="$HOME/.config/claude-container"
CACHE_DIR="$CONFIG_DIR/cache"

# Ensure directories exist
mkdir -p "$CONFIG_DIR" "$CACHE_DIR"
chmod 700 "$CONFIG_DIR"

# Source library modules (resolve symlinks to find actual script location)
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "$0" 2>/dev/null || realpath "$0" 2>/dev/null || echo "$0")")" && pwd)"
source "$SCRIPT_DIR/lib/utils.sh"
source "$SCRIPT_DIR/lib/platform.sh"
source "$SCRIPT_DIR/lib/container-detect.sh"
source "$SCRIPT_DIR/lib/config.sh"
source "$SCRIPT_DIR/lib/auth.sh"
source "$SCRIPT_DIR/lib/docker.sh"
source "$SCRIPT_DIR/lib/git-session.sh"
source "$SCRIPT_DIR/lib/session-mgmt.sh"

# Global state variables
DOCKERFILE=""
SESSION_DIR=""
VERIFY_MODE=false
SESSION_NAME=""
SESSION_NAME_SET=false
USE_GIT_SESSION=true  # Default: use git-based session isolation
CONTINUE_SESSION=false
RUN_AS_USER=false
RUN_AS_ROOTISH=true  # Default: run as user with passwordless sudo for package installs
NO_RUN=false
SHELL_ONLY=false
BASH_EXEC=""  # Command to execute instead of claude
ENABLE_DOCKER=false  # Mount Docker socket for host Docker access
CONFIG_ONLY=false    # Just generate config, don't create session
DISCOVER_REPOS_DIRS=()  # Array for multiple --discover-repos
ADD_REPOS=()  # Array for repos to add via --add-repo
SESSIONS_CONFIG_DIR="$CONFIG_DIR/sessions"  # Where session configs are stored
CLAUDE_ARGS=()  # Arguments to pass through to claude
NO_INTERACTIVE=false  # Fail fast if no token found (don't start OAuth flow)

# Docker args accumulator
declare -a DOCKER_ARGS

# Action flags (only one action can be performed at a time)
ACTION=""
ACTION_FORCE=false
ACTION_YES=false
ACTION_REGEX=false
IMPORT_SOURCE=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dir|-d)
            SESSION_DIR="$2"
            shift 2
            ;;
        --verify|-v)
            VERIFY_MODE=true
            shift
            ;;
        --session|-s)
            SESSION_NAME="$2"
            SESSION_NAME_SET=true
            shift 2
            ;;
        --no-git-session)
            USE_GIT_SESSION=false
            shift
            ;;
        --config-only)
            CONFIG_ONLY=true
            shift
            ;;
        --continue|-c)
            CONTINUE_SESSION=true
            shift
            ;;
        --token|-t)
            CLAUDE_CODE_OAUTH_TOKEN="$2"
            export CLAUDE_CODE_OAUTH_TOKEN
            shift 2
            ;;
        --as-user)
            RUN_AS_USER=true
            shift
            ;;
        --as-rootish)
            RUN_AS_ROOTISH=true
            shift
            ;;
        --as-root|--no-rootish)
            RUN_AS_ROOTISH=false
            RUN_AS_USER=false
            shift
            ;;
        --discover-repos)
            DISCOVER_REPOS_DIRS+=("$2")
            shift 2
            ;;
        --add-repo|-a)
            ADD_REPOS+=("$2")
            shift 2
            ;;
        --config|-C)
            CONFIG_FILE="$2"
            shift 2
            ;;
        --no-run)
            NO_RUN=true
            shift
            ;;
        --shell|--bash)
            SHELL_ONLY=true
            shift
            ;;
        --bash-exec)
            BASH_EXEC="$2"
            shift 2
            ;;
        --docker)
            ENABLE_DOCKER=true
            shift
            ;;
        --no-interactive)
            NO_INTERACTIVE=true
            shift
            ;;

        # Session management actions (use with --session)
        --extract)
            ACTION="extract"
            shift
            ;;
        --delete)
            ACTION="delete"
            shift
            ;;
        --repair)
            ACTION="repair"
            shift
            ;;
        --restart)
            ACTION="restart"
            shift
            ;;
        --import)
            ACTION="import"
            IMPORT_SOURCE="$2"
            shift 2
            ;;

        # Actions without session requirement
        --sessions|--list-sessions)
            ACTION="list"
            shift
            ;;
        --cleanup)
            ACTION="cleanup"
            shift
            ;;
        --cleanup-unused)
            ACTION="cleanup-unused"
            shift
            ;;

        # Action modifiers
        --force|-f)
            ACTION_FORCE=true
            shift
            ;;
        --yes|-y)
            ACTION_YES=true
            shift
            ;;
        --regex|-r)
            ACTION_REGEX=true
            shift
            ;;

        --dockerfile)
            # Specify explicit Dockerfile path (auto-detected if not provided)
            if [[ -n "${2:-}" ]] && [[ ! "$2" =~ ^- ]]; then
                DOCKERFILE="$2"
                shift 2
            else
                shift
            fi
            ;;
        --version|-V)
            echo "claude-container $VERSION"
            exit 0
            ;;
        --)
            # All remaining args go to claude
            shift
            CLAUDE_ARGS=("$@")
            break
            ;;
        --help|-h)
            cat <<EOF
Usage: claude-container [options] [-- <claude-args>]

Spawn into a Docker container with Claude Code ready.

Options:
  --session, -s <name>     Session name (required for git sessions)
  --add-repo, -a <path>    Add a git repository to the session (can use multiple times)
  --discover-repos <dir>   Auto-discover all git repos in directory
  --config, -C <path>      Path to .claude-projects.yml config file
  --continue, -c           Continue the most recent Claude conversation
  --no-git-session         Disable git-based isolation (mount cwd directly)
  --config-only            Generate config file only, don't create session
  --dockerfile [path]      Use Dockerfile (auto-detected, or set in config)
  --token, -t <token>      Provide OAuth token directly
  --as-user                Run as non-root developer user (no sudo)
  --as-rootish             Run as developer with passwordless sudo (default)
  --as-root, --no-rootish  Run as actual root user
  --shell, --bash          Start bash shell instead of claude
  --bash-exec <cmd>        Execute a bash command and exit
  --docker                 Mount Docker socket for host Docker access
  --no-interactive         Exit with error if no token found
  --no-run                 Set up session but don't start container
  --verify, -v             Verify container setup works
  --version, -V            Show version
  --help, -h               Show this help

Arguments:
  -- <claude-args>         Pass remaining arguments to claude (e.g., -p, --print)

Session Management (use with -s <session>):
  --extract                Extract session as branch
  --delete                 Delete session volumes
  --repair                 Fix corrupted session config
  --restart                Restart session (fixes permissions)
  --import <path>          Import claude session data from path

  Modifiers: --force/-f, --yes/-y, --regex/-r

Global Commands (no session required):
  --sessions               List all sessions with disk usage
  --cleanup                List and optionally delete all volumes
  --cleanup-unused         Delete unused volumes [--yes]

Examples:
  # Single project
  claude-container -s myproj

  # Multiple projects
  claude-container -s myproj -a ~/repo1 -a ~/repo2

  # Auto-discover repos in a directory
  claude-container -s myproj --discover-repos ~/dev

  # Resume session and continue conversation
  claude-container -s myproj --continue

  # Extract changes as a branch
  claude-container -s myproj --extract

  # Delete a session
  claude-container -s myproj --delete --yes

  # Run claude in print mode
  claude-container -s myproj -- -p "What is this?"

Workflow:
  1. Start session:     claude-container -s myproj
  2. Do work in container...
  3. Exit container:    exit
  4. Extract as branch: claude-container -s myproj --extract
  5. Use git normally:  git checkout myproj  OR  git merge myproj
EOF
            exit 0
            ;;
        *)
            error "Unknown option: $1"
            echo "Run 'claude-container --help' for usage"
            exit 1
            ;;
    esac
done

# Handle actions that don't require a session
case "$ACTION" in
    list)
        session_list
        exit 0
        ;;
    cleanup)
        session_cleanup
        exit 0
        ;;
    cleanup-unused)
        $ACTION_YES && session_cleanup_unused --yes || session_cleanup_unused
        exit 0
        ;;
esac

# Handle actions that require a session name
if [[ -n "$ACTION" ]]; then
    if [[ -z "$SESSION_NAME" ]]; then
        error "Session name required: use --session <name> with --$ACTION"
        exit 1
    fi

    case "$ACTION" in
        extract)
            $ACTION_FORCE && session_extract "$SESSION_NAME" --force || session_extract "$SESSION_NAME"
            exit 0
            ;;
        delete)
            delete_args=("$SESSION_NAME")
            $ACTION_REGEX && delete_args+=(--regex)
            $ACTION_YES && delete_args+=(--yes)
            session_delete "${delete_args[@]}"
            exit 0
            ;;
        repair)
            session_repair "$SESSION_NAME"
            exit 0
            ;;
        restart)
            session_restart "$SESSION_NAME" "$0"
            exit 0
            ;;
        import)
            if [[ -z "$IMPORT_SOURCE" ]]; then
                error "--import requires a source path"
                exit 1
            fi
            $ACTION_FORCE && session_import "$IMPORT_SOURCE" "$SESSION_NAME" --force || session_import "$IMPORT_SOURCE" "$SESSION_NAME"
            exit 0
            ;;
    esac
fi

# Validate session name is provided when required
if ($USE_GIT_SESSION || $CONFIG_ONLY || [[ ${#ADD_REPOS[@]} -gt 0 ]]) && [[ -z "$SESSION_NAME" ]]; then
    error "Session name required: use --session <name>"
    exit 1
fi

# Validate --add-repo requires git session mode
if [[ ${#ADD_REPOS[@]} -gt 0 ]] && ! $USE_GIT_SESSION; then
    error "--add-repo requires git session mode (use --session)"
    exit 1
fi

# Ensure session config directory exists
mkdir -p "$SESSIONS_CONFIG_DIR"

# Ensure token is available (from config, keychain, or interactive auth)
ensure_token

# Check for YAML parser if we'll need it (multi-project mode)
if $USE_GIT_SESSION || [[ -n "$CONFIG_FILE" ]]; then
    will_use_config=false
    if [[ -n "$CONFIG_FILE" ]]; then
        will_use_config=true
    elif $USE_GIT_SESSION; then
        workspace="${WORKSPACE_DIR:-$(pwd)}"
        for candidate in \
            "$workspace/.claude-projects.yml" \
            "$workspace/.devcontainer/claude-projects.yml" \
            "$workspace/claude-projects.yml"; do
            if [[ -f "$candidate" ]]; then
                will_use_config=true
                break
            fi
        done
    fi

    if $will_use_config && ! check_yaml_parser_available; then
        echo ""
        warn "Multi-project config detected but YAML parser not available"
        show_yaml_parser_install_help
        exit 1
    fi
fi

# Determine image to use
# Priority: 1. --dockerfile flag, 2. config file dockerfile field, 3. local Dockerfile, 4. default image
if [[ -z "$DOCKERFILE" ]]; then
    # Check config file for dockerfile field
    if [[ -n "${CONFIG_FILE:-}" ]] && command -v yq &>/dev/null; then
        config_dockerfile=$(yq eval '.dockerfile // ""' "$CONFIG_FILE" 2>/dev/null || echo "")
        if [[ -n "$config_dockerfile" ]]; then
            # Resolve relative to config file location
            if [[ "$config_dockerfile" != /* ]]; then
                config_dir=$(dirname "$CONFIG_FILE")
                DOCKERFILE="$config_dir/$config_dockerfile"
            else
                DOCKERFILE="$config_dockerfile"
            fi
        fi
    fi
fi

if [[ -z "$DOCKERFILE" ]]; then
    # Search for Dockerfile in standard locations
    for candidate in "./Dockerfile" "./.devcontainer/Dockerfile" "./docker/Dockerfile"; do
        if [[ -f "$candidate" ]]; then
            DOCKERFILE="$candidate"
            break
        fi
    done
fi

if [[ -n "$DOCKERFILE" ]]; then
    if [[ ! -f "$DOCKERFILE" ]]; then
        error "Dockerfile not found: $DOCKERFILE"
        exit 1
    fi
    USE_DEFAULT_IMAGE=false
else
    # No local Dockerfile found, use default image
    USE_DEFAULT_IMAGE=true
    IMAGE_NAME="$DEFAULT_IMAGE"
fi

if $USE_DEFAULT_IMAGE; then
    IMAGE_EXISTS=$(docker images -q "$IMAGE_NAME" 2>/dev/null)
    if [[ -z "$IMAGE_EXISTS" ]]; then
        info "Pulling image: $IMAGE_NAME"
        docker pull "$IMAGE_NAME" &
        spin $!
        wait $!
        success "Image pulled: $IMAGE_NAME"
        echo ""
    fi
else
    info "Using Dockerfile: $DOCKERFILE"
    CONTEXT_DIR="$(dirname "$DOCKERFILE")"
    if [[ "$CONTEXT_DIR" == "." ]]; then
        CONTEXT_DIR="$(pwd)"
    fi
    PROJECT_NAME="$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]-')"
    IMAGE_NAME="claude-dev-${PROJECT_NAME}"

    # Check if image needs rebuilding (doesn't exist or Dockerfile is newer)
    IMAGE_EXISTS=$(docker images -q "$IMAGE_NAME" 2>/dev/null)
    NEEDS_BUILD=false
    if [[ -z "$IMAGE_EXISTS" ]]; then
        NEEDS_BUILD=true
    else
        # Check if Dockerfile is newer than image
        IMAGE_CREATED=$(docker inspect -f '{{.Created}}' "$IMAGE_NAME" 2>/dev/null | cut -d'T' -f1 | tr -d '-')
        DOCKERFILE_MODIFIED=$(stat -f %Sm -t %Y%m%d "$DOCKERFILE" 2>/dev/null || stat -c %Y "$DOCKERFILE" 2>/dev/null | xargs -I{} date -d @{} +%Y%m%d 2>/dev/null || echo "0")
        if [[ "$DOCKERFILE_MODIFIED" > "$IMAGE_CREATED" ]]; then
            NEEDS_BUILD=true
        fi
    fi

    if $NEEDS_BUILD; then
        info "Building image: $IMAGE_NAME"
        docker build -t "$IMAGE_NAME" -f "$DOCKERFILE" "$CONTEXT_DIR" &
        spin $!
        wait $!
        success "Image built: $IMAGE_NAME"
        echo ""
    fi
fi

# Prepare mount points
WORKSPACE_DIR="$(pwd)"
USE_OVERLAY=false

# Handle session directory with overlay (deprecated)
SESSION_VOLUME=""
if [[ -n "$SESSION_DIR" ]]; then
    warn "The --dir option is deprecated. Use --session instead."
    SESSION_DIR="$(cd "$SESSION_DIR" && pwd)"
    SESSION_UUID="$(uuidgen | tr '[:upper:]' '[:lower:]')"
    SESSION_VOLUME="session-data-${SESSION_UUID}"
    info "Creating session volume: $SESSION_VOLUME"
    docker volume create "$SESSION_VOLUME" >/dev/null
    USE_OVERLAY=true
    WORKSPACE_DIR="$SESSION_DIR"
fi

# Handle --config-only: generate config and exit
if $CONFIG_ONLY; then
    if [[ ${#DISCOVER_REPOS_DIRS[@]} -gt 0 ]]; then
        # Discover repos and write config to session config dir
        discovered_config=$(discover_repos_multi "${DISCOVER_REPOS_DIRS[@]}")
        session_config="$SESSIONS_CONFIG_DIR/${SESSION_NAME}.yml"
        cp "$discovered_config" "$session_config"
        rm -f "$discovered_config"
        success "Config written to: $session_config"
        echo "$session_config"
        exit 0
    elif [[ -n "${CONFIG_FILE:-}" ]]; then
        # Copy provided config to session config dir
        session_config="$SESSIONS_CONFIG_DIR/${SESSION_NAME}.yml"
        cp "$CONFIG_FILE" "$session_config"
        success "Config copied to: $session_config"
        echo "$session_config"
        exit 0
    else
        error "--config-only requires --discover-repos or --config"
        exit 1
    fi
fi

# Handle git-based session isolation (recommended)
GIT_SESSION_VOLUME=""
if $USE_GIT_SESSION; then
    GIT_SESSION_VOLUME="claude-session-${SESSION_NAME}"

    # If --discover-repos was specified, write config to session config dir first
    if [[ ${#DISCOVER_REPOS_DIRS[@]} -gt 0 ]]; then
        discovered_config=$(discover_repos_multi "${DISCOVER_REPOS_DIRS[@]}")
        session_config="$SESSIONS_CONFIG_DIR/${SESSION_NAME}.yml"
        cp "$discovered_config" "$session_config"
        rm -f "$discovered_config"
        CONFIG_FILE="$session_config"
        info "Session config: $session_config"
    fi

    create_git_session "$SESSION_NAME" "$WORKSPACE_DIR"

    # Handle --add-repo: add repos to session (works for both new and existing sessions)
    if [[ ${#ADD_REPOS[@]} -gt 0 ]]; then
        for repo_path in "${ADD_REPOS[@]}"; do
            session_add_repo "$SESSION_NAME" "$repo_path"
        done
    fi

    if $NO_RUN; then
        success "Session ready: $SESSION_NAME"
        exit 0
    fi
fi

# Build docker run command
DOCKER_ARGS=(
    "--rm"
    "--name" "claude-dev-$$"
    "-w" "/workspace"
)

# Add TTY based on CI detection and terminal availability
if $IS_CI; then
    :
elif ! $VERIFY_MODE && [[ -t 0 ]]; then
    DOCKER_ARGS+=("-it")
fi

# Mount workspace
if $USE_GIT_SESSION; then
    DOCKER_ARGS+=("-v" "$GIT_SESSION_VOLUME:/workspace")
elif $USE_OVERLAY; then
    DOCKER_ARGS+=(
        "--privileged"
        "--device" "/dev/fuse"
        "-v" "$WORKSPACE_DIR:/workspace-lower:ro"
        "-v" "$SESSION_VOLUME:/session-data"
        "-e" "USE_OVERLAY=1"
        "-e" "SESSION_VOLUME=$SESSION_VOLUME"
    )
else
    DOCKER_ARGS+=("-v" "$WORKSPACE_DIR:/workspace")
fi

# Mount git config and SSH
DOCKER_ARGS+=(
    "-v" "$HOME/.gitconfig:/root/.gitconfig:ro"
    "-v" "$HOME/.ssh:/root/.ssh:ro"
)

# Forward SSH agent if available
SSH_SOCKET_ARGS=$(get_ssh_socket_args)
if [[ -n "$SSH_SOCKET_ARGS" ]]; then
    # shellcheck disable=SC2086
    DOCKER_ARGS+=($SSH_SOCKET_ARGS)
fi

# Add environment variables
DOCKER_ARGS+=(
    "-e" "TERM=${TERM:-xterm-256color}"
    "-e" "HOST_UID=$(get_host_uid)"
    "-e" "HOST_GID=$(get_host_gid)"
    "-e" "PLATFORM=$PLATFORM"
    "-e" "IS_CI=$IS_CI"
)

# Inject token securely
inject_token_securely "${CLAUDE_CODE_OAUTH_TOKEN}"

# Set up session state and dev caches
setup_session_state "$SESSION_NAME"
setup_dev_caches "$SESSION_NAME"

if $VERIFY_MODE; then
    DOCKER_ARGS+=("-e" "VERIFY_MODE=1")
fi

if $CONTINUE_SESSION; then
    DOCKER_ARGS+=("-e" "CONTINUE_SESSION=1")
fi

if $RUN_AS_USER; then
    DOCKER_ARGS+=("-e" "RUN_AS_USER=1")
fi

if $RUN_AS_ROOTISH; then
    DOCKER_ARGS+=("-e" "RUN_AS_ROOTISH=1")
fi

if $SHELL_ONLY; then
    DOCKER_ARGS+=("-e" "SHELL_ONLY=1")
fi

if [[ -n "$BASH_EXEC" ]]; then
    DOCKER_ARGS+=("-e" "BASH_EXEC=$BASH_EXEC")
fi

# Pass through claude args if provided
if [[ ${#CLAUDE_ARGS[@]} -gt 0 ]]; then
    # Serialize the array as a base64-encoded string to preserve spaces and special chars
    CLAUDE_PASSTHROUGH_ARGS=$(printf '%s\n' "${CLAUDE_ARGS[@]}" | base64 -w 0 2>/dev/null || printf '%s\n' "${CLAUDE_ARGS[@]}" | base64)
    DOCKER_ARGS+=("-e" "CLAUDE_PASSTHROUGH_ARGS=$CLAUDE_PASSTHROUGH_ARGS")
fi

if $ENABLE_DOCKER; then
    # Verify Docker is accessible from host
    DOCKER_AVAILABLE=false
    if command -v docker &>/dev/null; then
        DOCKER_HOST_URL=$(docker context inspect --format '{{.Endpoints.docker.Host}}' 2>/dev/null)
        if [[ -n "$DOCKER_HOST_URL" ]] && [[ "$DOCKER_HOST_URL" == unix://* ]]; then
            HOST_SOCKET="${DOCKER_HOST_URL#unix://}"
            if [[ -S "$HOST_SOCKET" ]]; then
                DOCKER_AVAILABLE=true
            fi
        fi
    fi

    if $DOCKER_AVAILABLE; then
        # Mount the VM-side socket (works for Colima/Docker Desktop on macOS)
        DOCKER_ARGS+=("-v" "/var/run/docker.sock:/var/run/docker.sock")
        DOCKER_ARGS+=("-e" "DOCKER_HOST=unix:///var/run/docker.sock")
        if [[ "$PLATFORM" == "linux" ]]; then
            warn "Docker socket mounted - this grants full Docker access"
            warn "On Linux, this is equivalent to root access on the host"
        else
            info "Docker socket mounted (VM: /var/run/docker.sock)"
        fi
    else
        warn "Could not find Docker socket - --docker will not work"
        if command -v docker &>/dev/null; then
            warn "Active context: $(docker context show 2>/dev/null || echo 'unknown')"
        fi
    fi
fi

info "Starting container..."
echo "  Image: $IMAGE_NAME"
if $USE_GIT_SESSION; then
    echo "  Workspace: $GIT_SESSION_VOLUME -> /workspace (git session)"
else
    echo "  Workspace: $WORKSPACE_DIR -> /workspace"
fi
echo "  Platform: $PLATFORM"
echo "  State: claude-state-${SESSION_NAME}"
if $IS_CI; then
    echo "  CI Mode: enabled"
fi
if $USE_OVERLAY; then
    echo "  Session: $SESSION_VOLUME (overlay mode - deprecated)"
fi
if $USE_GIT_SESSION; then
    echo "  Git Session: $SESSION_NAME"
fi
if $ENABLE_DOCKER && ${DOCKER_AVAILABLE:-false}; then
    echo "  Docker: enabled (/var/run/docker.sock)"
fi
echo ""

# Run container with entrypoint script
docker run "${DOCKER_ARGS[@]}" "$IMAGE_NAME" /bin/bash -c '
    set -e

    # Read token from securely mounted file OR from nested env var
    if [[ -n "${CLAUDE_CODE_OAUTH_TOKEN_NESTED:-}" ]]; then
        # Nested container mode - token passed via env var
        export CLAUDE_CODE_OAUTH_TOKEN="$CLAUDE_CODE_OAUTH_TOKEN_NESTED"
    elif [[ -f /run/secrets/claude_token ]]; then
        # Normal mode - token mounted as file
        export CLAUDE_CODE_OAUTH_TOKEN=$(cat /run/secrets/claude_token)
    else
        echo "ERROR: No token found (neither file nor env var)" >&2
        exit 1
    fi

    HOST_UID=${HOST_UID:-1000}
    DEV_GID=61000

    # Set up overlayfs if requested
    if [[ "${USE_OVERLAY:-}" == "1" ]]; then
        echo "Setting up overlay filesystem..."
        mkdir -p /session-data/upper /session-data/work
        rmdir /workspace 2>/dev/null || rm -f /workspace 2>/dev/null || true
        mkdir -p /workspace
        if fuse-overlayfs \
            -o lowerdir=/workspace-lower,upperdir=/session-data/upper,workdir=/session-data/work \
            /workspace 2>&1; then
            echo "  Overlay mounted at /workspace"
        else
            mount --bind /workspace-lower /workspace 2>/dev/null || ln -sf /workspace-lower /workspace
            echo "  Fallback: direct mount, read-only"
        fi
        cd /workspace
        echo ""
    fi

    # Set up home directory
    mkdir -p /home/developer/.claude /home/developer/.cargo /home/developer/.npm /home/developer/.cache/pip

    # Create .claude.json with settings
    cat > /home/developer/.claude.json << EOF
{"theme":"dark-ansi","hasCompletedOnboarding":true,"bypassPermissionsModeAccepted":true}
EOF

    # Copy git config
    if [[ -f /root/.gitconfig ]]; then
        cp /root/.gitconfig /home/developer/.gitconfig 2>/dev/null || true
    fi

    # Check for docker CLI if socket is mounted
    if [[ -S /var/run/docker.sock ]] && ! command -v docker &>/dev/null; then
        echo "WARNING: docker socket mounted but docker CLI not found"
        echo "         Use --dockerfile to build an image with docker"
    fi

    if [[ "${RUN_AS_USER:-}" == "1" ]] || [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then
        groupadd -g $DEV_GID developer 2>/dev/null || true
        useradd -u $HOST_UID -g $DEV_GID -m -s /bin/bash developer 2>/dev/null || true
        chown -R developer:developer /home/developer
        chown developer:developer /workspace 2>/dev/null || true

        # Make docker socket accessible if mounted
        if [[ -S /var/run/docker.sock ]]; then
            chmod 666 /var/run/docker.sock 2>/dev/null || true
        fi

        if [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then
            if ! command -v sudo &>/dev/null; then
                echo "WARNING: sudo not found - rootish mode requires sudo in the image"
                echo "         Use --dockerfile to build an image with sudo, or use --as-root"
            else
                # Configure passwordless sudo for developer user
                echo "developer ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/developer
                chmod 0440 /etc/sudoers.d/developer

                # Create rootish wrapper that uses sudo
                cat > /usr/local/bin/rootish << '\''WRAPPER'\''
#!/bin/bash
exec sudo "$@"
WRAPPER
                chmod +x /usr/local/bin/rootish
            fi
        fi
    fi

    # Verify mode
    if [[ "${VERIFY_MODE:-}" == "1" ]]; then
        echo "=== Verification ==="
        echo "Run as: $(if [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then echo "developer (sudo)"; elif [[ "${RUN_AS_USER:-}" == "1" ]]; then echo "developer"; else echo "root"; fi)"
        echo "Claude: $(which claude 2>&1)"
        echo "Platform: ${PLATFORM:-unknown}"

        echo ""
        echo "=== Token Check ==="
        if [[ -n "${CLAUDE_CODE_OAUTH_TOKEN:-}" ]]; then
            if [[ -f /run/secrets/claude_token ]]; then
                echo "  Token source: file"
            elif [[ -n "${CLAUDE_CODE_OAUTH_TOKEN_NESTED:-}" ]]; then
                echo "  Token source: nested env var"
            else
                echo "  Token source: environment"
            fi
            echo "  Token: ${CLAUDE_CODE_OAUTH_TOKEN:0:20}..."
        else
            echo "  Token missing"
            exit 1
        fi

        echo ""
        echo "=== Claude Test ==="
        HOME=/home/developer claude --print "test" 2>&1 | head -5
        exit 0
    fi

    # Determine working directory (main project if specified, otherwise /workspace)
    WORK_DIR="/workspace"
    if [[ -f /workspace/.main-project ]]; then
        MAIN_PROJ=$(cat /workspace/.main-project)
        if [[ -d "/workspace/$MAIN_PROJ" ]]; then
            WORK_DIR="/workspace/$MAIN_PROJ"
        fi
    fi

    # Shell-only mode - just run bash in working directory
    if [[ "${SHELL_ONLY:-}" == "1" ]]; then
        if [[ "${RUN_AS_USER:-}" == "1" ]] || [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then
            exec gosu developer bash -c "export CLAUDE_CODE_OAUTH_TOKEN='\''$CLAUDE_CODE_OAUTH_TOKEN'\'' && cd $WORK_DIR && exec bash"
        else
            exec bash -c "cd $WORK_DIR && exec bash"
        fi
    fi

    # Bash exec mode - run command and exit
    if [[ -n "${BASH_EXEC:-}" ]]; then
        cd $WORK_DIR
        if [[ "${RUN_AS_USER:-}" == "1" ]] || [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then
            exec gosu developer bash -c "$BASH_EXEC"
        else
            exec bash -c "$BASH_EXEC"
        fi
    fi

    # Build claude command arguments
    CLAUDE_CMD_ARGS=""

    # Add permission flag if running as user
    if [[ "${RUN_AS_USER:-}" == "1" ]] || [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then
        CLAUDE_CMD_ARGS="--dangerously-skip-permissions"
    fi

    # Add --continue if requested
    if [[ "${CONTINUE_SESSION:-}" == "1" ]]; then
        CLAUDE_CMD_ARGS="--continue $CLAUDE_CMD_ARGS"
    fi

    # Add passthrough args if provided
    if [[ -n "${CLAUDE_PASSTHROUGH_ARGS:-}" ]]; then
        # Decode the base64-encoded args
        PASSTHROUGH_DECODED=$(echo "$CLAUDE_PASSTHROUGH_ARGS" | base64 -d 2>/dev/null || echo "$CLAUDE_PASSTHROUGH_ARGS" | base64 -D 2>/dev/null)
        # Append each arg (properly quoted for arguments with spaces)
        while IFS= read -r arg; do
            if [[ -n "$arg" ]]; then
                # Quote the argument if it contains spaces
                if [[ "$arg" =~ \  ]]; then
                    CLAUDE_CMD_ARGS="$CLAUDE_CMD_ARGS \"$arg\""
                else
                    CLAUDE_CMD_ARGS="$CLAUDE_CMD_ARGS $arg"
                fi
            fi
        done <<< "$PASSTHROUGH_DECODED"
    fi

    cd $WORK_DIR
    if [[ "${RUN_AS_USER:-}" == "1" ]] || [[ "${RUN_AS_ROOTISH:-}" == "1" ]]; then
        exec gosu developer bash -c "claude $CLAUDE_CMD_ARGS"
    else
        exec bash -c "HOME=/home/developer claude $CLAUDE_CMD_ARGS"
    fi
'

# Session exit message
if $USE_GIT_SESSION; then
    echo ""
    info "Session complete: $SESSION_NAME"
    echo ""
    echo "To extract changes:"
    echo "  claude-container --extract $SESSION_NAME"
fi
